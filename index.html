<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crypto Crush</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none;
        }

        .game-container {
            max-width: 500px;
            width: 100%;
            padding: 10px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .board-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            background: #f0f0f0;
            padding: 8px;
            border-radius: 10px;
            touch-action: none;
        }

        .cell {
            aspect-ratio: 1;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            position: relative;
            user-select: none;
            touch-action: none;
        }

        .cell:active {
            transform: scale(0.95);
        }

        .cell.selected {
            box-shadow: 0 0 0 3px #667eea;
            transform: scale(1.05);
        }

        .cell.matched {
            animation: pulse 0.3s;
        }

        .cell.dragging {
            z-index: 100;
            opacity: 0.8;
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .cell.drag-over {
            background: #e8f5e8;
            border: 2px dashed #4CAF50;
        }

        .swipe-indicator {
            position: absolute;
            background: rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
            transition: all 0.2s;
        }

        .crypto-icon {
            width: 80%;
            height: 80%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .crypto-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .buttons-3cols {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 12px;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            color: #667eea;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #667eea;
            text-align: center;
        }

        .quest-item {
            background: #f5f5f5;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .quest-item.subscribe-quest {
            background: linear-gradient(135deg, #667eea15, #764ba215);
            border: 2px solid #667eea;
        }

        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .quest-title {
            font-weight: bold;
            color: #333;
        }

        .quest-reward {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .quest-progress {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }

        .quest-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .quest-bar-fill {
            height: 100%;
            background: #667eea;
            transition: width 0.3s;
        }

        .quest-completed {
            opacity: 0.6;
        }

        .claim-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            width: 100%;
        }

        .claim-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .subscribe-btn {
            background: #0088cc;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .verify-btn {
            background: #FF6B35;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 5px;
            width: 100%;
        }

        .verification-status {
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }

        .close-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
        }

        .combo-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 999;
            animation: comboAnim 1s ease-out;
        }

        @keyframes comboAnim {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        @keyframes slideDown {
            0% { transform: translate(-50%, -100%); opacity: 0; }
            100% { transform: translate(-50%, 0); opacity: 1; }
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .leaderboard-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .leaderboard-item.current-player {
            background: linear-gradient(135deg, #667eea15, #764ba215);
            border: 2px solid #667eea;
            font-weight: bold;
        }

        .leaderboard-rank {
            font-weight: bold;
            color: #667eea;
            min-width: 30px;
            font-size: 16px;
        }

        .leaderboard-name {
            flex: 1;
            margin: 0 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #764ba2;
            font-size: 16px;
        }

        .leaderboard-level {
            font-size: 12px;
            color: #666;
            margin-left: 5px;
        }

        .badge {
            display: inline-block;
            background: #FFD700;
            color: #333;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }

        .leaderboard-sync-status {
            text-align: center;
            padding: 10px;
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .sync-button {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 5px;
        }

        .sync-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">–û—á–∫–∏</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">–£—Ä–æ–≤–µ–Ω—å</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">–•–æ–¥—ã</div>
                    <div class="stat-value" id="moves">30</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">–ë—É—Å—Ç–µ—Ä—ã</div>
                    <div class="stat-value" id="boosters">3</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress"></div>
            </div>
        </div>

        <div class="board-container">
            <div class="game-board" id="gameBoard"></div>
        </div>

        <div class="buttons-3cols">
            <button class="btn" onclick="showQuests()">üìã –ó–∞–¥–∞–Ω–∏—è</button>
            <button class="btn" onclick="showLeaderboard()">üèÜ –õ–∏–¥–µ—Ä—ã</button>
            <button class="btn" onclick="useBooster()" id="boosterBtn">‚ö° –ë—É—Å—Ç–µ—Ä (3)</button>
            <button class="btn" onclick="manualSave()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button class="btn" onclick="restartGame()">üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        </div>
    </div>

    <div class="modal" id="questModal">
        <div class="modal-content">
            <div class="modal-title">üìã –ó–∞–¥–∞–Ω–∏—è</div>
            <div id="questList"></div>
            <button class="close-btn" onclick="closeModal('questModal')">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <div class="modal" id="leaderboardModal">
        <div class="modal-content">
            <div class="modal-title">üèÜ –¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</div>
            <div id="leaderboardList"></div>
            <button class="close-btn" onclick="closeModal('leaderboardModal')">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
        }

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç —Å SVG –∏–∫–æ–Ω–∫–∞–º–∏ –∏–∑ CDN
        const CRYPTOS = [
            { 
                name: 'BTC', 
                icon: './logo/btc.svg',
                color: '#F7931A' 
            },
            { 
                name: 'ETH', 
                icon: './logo/eth.svg',
                color: '#627EEA' 
            },
            { 
                name: 'BNB', 
                icon: './logo/bnb.svg',
                color: '#F3BA2F' 
            },
            { 
                name: 'SOL', 
                icon: './logo/sol.svg',
                color: '#14F195' 
            },
            { 
                name: 'USDT', 
                icon: './logo/usdt.svg',
                color: '#26A17B' 
            },
            { 
                name: 'XRP', 
                icon: './logo/xrp.svg',
                color: '#23292F' 
            },
            { 
                name: 'TON', 
                icon: './logo/ton.svg',
                color: '#0088CC' 
            }
        ];

        const BOARD_SIZE = 8;
        let board = [];
        let selectedCell = null;
        let score = 0;
        let level = 1;
        let moves = 30;
        let boosters = 3;
        let combo = 0;
        let targetScore = 1000;

        // Drag and swipe variables
        let isDragging = false;
        let dragStartCell = null;
        let dragEndCell = null;
        let touchStartPos = null;
        let isSwipeMode = false;
        let swipeThreshold = 30; // Minimum distance for swipe

        let quests = [
            { id: 1, title: '–ü–µ—Ä–≤—ã–µ —à–∞–≥–∏', description: '–ù–∞–±–µ—Ä–∏—Ç–µ 500 –æ—á–∫–æ–≤', target: 500, current: 0, type: 'score', reward: 2, claimed: false },
            { id: 2, title: '–ú–∞—Å—Ç–µ—Ä –∫–æ–º–±–æ', description: '–°–¥–µ–ª–∞–π—Ç–µ –∫–æ–º–±–æ x3', target: 3, current: 0, type: 'combo', reward: 1, claimed: false },
            { id: 3, title: '–°–æ–±–∏—Ä–∞—Ç–µ–ª—å BTC', description: '–£–Ω–∏—á—Ç–æ–∂—å—Ç–µ 50 BTC', target: 50, current: 0, type: 'btc', reward: 3, claimed: false },
            { id: 4, title: '–ü–æ–∫–æ—Ä–∏—Ç–µ–ª—å —É—Ä–æ–≤–Ω–µ–π', description: '–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 5 —É—Ä–æ–≤–Ω—è', target: 5, current: 1, type: 'level', reward: 5, claimed: false },
            { id: 5, title: '–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü', description: '–°—ã–≥—Ä–∞–π—Ç–µ 10 –∏–≥—Ä', target: 10, current: 0, type: 'games', reward: 3, claimed: false },
            { id: 6, title: '–ë–æ–ª—å—à–æ–π –º–∞—Ç—á', description: '–°–¥–µ–ª–∞–π—Ç–µ –º–∞—Ç—á –∏–∑ 5+ –º–æ–Ω–µ—Ç', target: 1, current: 0, type: 'bigmatch', reward: 2, claimed: false },
            { id: 7, title: '–ú–∏–ª–ª–∏–æ–Ω–µ—Ä', description: '–ù–∞–±–µ—Ä–∏—Ç–µ 10000 –æ—á–∫–æ–≤ –∑–∞ –∏–≥—Ä—É', target: 10000, current: 0, type: 'score', reward: 10, claimed: false },
            { id: 8, title: '–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å', description: '–ó–∞–∫–æ–Ω—á–∏—Ç–µ —É—Ä–æ–≤–µ–Ω—å –∑–∞ 10 —Ö–æ–¥–æ–≤', target: 1, current: 0, type: 'efficiency', reward: 4, claimed: false },
            { id: 9, title: '–ü–æ–¥–ø–∏—Å—á–∏–∫', description: '–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª', target: 1, current: 0, type: 'subscribe', reward: 5, claimed: false, channelUsername: '@cryptonftded' }
        ];

        // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Telegram Cloud Storage
        function loadGameData() {
            return new Promise((resolve) => {
                if (!tg || !tg.CloudStorage) {
                    // Fallback –Ω–∞ localStorage –µ—Å–ª–∏ Telegram API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                    const saved = localStorage.getItem('cryptoCrushSave');
                    if (saved) {
                        try {
                            const data = JSON.parse(saved);
                            loadGameState(data);
                        } catch (e) {
                            console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage:', e);
                        }
                    }
                    resolve();
                    return;
                }

                try {
                    const keys = ['gameSave', 'quests', 'boosters'];
                    tg.CloudStorage.getItems(keys, (error, result) => {
                        if (!error && result) {
                            if (result.gameSave) {
                                try {
                                    const saveData = JSON.parse(result.gameSave);
                                    loadGameState(saveData);
                                } catch (e) {
                                    console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ gameSave:', e);
                                }
                            } else if (result.quests) {
                                try {
                                    quests = JSON.parse(result.quests);
                                    if (result.boosters) {
                                        boosters = parseInt(result.boosters);
                                    }
                                    updateStats();
                                } catch (e) {
                                    console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ quests:', e);
                                }
                            }
                        } else {
                            // Fallback –Ω–∞ localStorage
                            const saved = localStorage.getItem('cryptoCrushSave');
                            if (saved) {
                                try {
                                    const data = JSON.parse(saved);
                                    loadGameState(data);
                                } catch (e) {
                                    console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage:', e);
                                }
                            }
                        }
                        resolve();
                    });
                } catch (e) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ Telegram Cloud:', e);
                    const saved = localStorage.getItem('cryptoCrushSave');
                    if (saved) {
                        try {
                            const data = JSON.parse(saved);
                            loadGameState(data);
                        } catch (parseErr) {
                            console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage:', parseErr);
                        }
                    }
                    resolve();
                }
            });
        }

        let boardRestoredFromSave = false;

        // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        function loadGameState(data) {
            if (data.quests) {
                // Merge saved quests with default quests to preserve any new quests added in updates
                const savedQuestMap = {};
                data.quests.forEach(q => { savedQuestMap[q.id] = q; });
                quests = quests.map(q => savedQuestMap[q.id] || q);
            }
            if (data.boosters !== undefined) boosters = data.boosters;

            // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä—ã –µ—Å–ª–∏ –µ—Å—Ç—å
            if (data.currentGame && data.currentGame.board) {
                board = data.currentGame.board;
                score = data.currentGame.score || 0;
                level = data.currentGame.level || 1;
                moves = data.currentGame.moves || 30;
                combo = data.currentGame.combo || 0;
                targetScore = data.currentGame.targetScore || 1000;
                boardRestoredFromSave = true;
                renderBoard();
                return;
            }

            updateStats();
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ Telegram Cloud Storage
        function saveGameData(saveCurrentGame = false) {
            const data = {
                quests: quests,
                boosters: boosters,
                highScore: getHighScore(),
                lastSaved: new Date().toISOString()
            };

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if (saveCurrentGame && moves > 0) {
                data.currentGame = {
                    board: board,
                    score: score,
                    level: level,
                    moves: moves,
                    combo: combo,
                    targetScore: targetScore
                };
            }

            // –í—Å–µ–≥–¥–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
            try {
                localStorage.setItem('cryptoCrushSave', JSON.stringify(data));
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ localStorage:', e);
            }

            if (!tg || !tg.CloudStorage) {
                return;
            }

            try {
                tg.CloudStorage.setItem('gameSave', JSON.stringify(data), (error) => {
                    if (error) {
                        console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Telegram Cloud:', error);
                    }
                });
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞ Telegram CloudStorage:', e);
            }
        }

        // –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
        let autoSaveInterval;
        function startAutoSave() {
            autoSaveInterval = setInterval(() => {
                if (moves > 0) {
                    saveGameData(true);
                    console.log('üîÑ –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...');
                }
            }, 30000);
        }

        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
        }

        // –†—É—á–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        function manualSave() {
            if (moves <= 0) {
                alert('‚ÑπÔ∏è –ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å - –∏–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞!');
                return;
            }
            
            saveGameData(true);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏
            const saveNotification = document.createElement('div');
            saveNotification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #4CAF50;
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                font-weight: bold;
                z-index: 1001;
                animation: slideDown 0.3s ease-out;
            `;
            saveNotification.textContent = '‚úÖ –ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!';
            document.body.appendChild(saveNotification);
            
            setTimeout(() => {
                saveNotification.remove();
            }, 2000);
        }

        function initBoard() {
            board = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                board[i] = [];
                for (let j = 0; j < BOARD_SIZE; j++) {
                    board[i][j] = getRandomCrypto();
                }
            }
            removeInitialMatches();
            renderBoard();
        }

        function getRandomCrypto() {
            return CRYPTOS[Math.floor(Math.random() * CRYPTOS.length)];
        }

        function removeInitialMatches() {
            let hasMatches = true;
            while (hasMatches) {
                hasMatches = false;
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (checkMatchAt(i, j)) {
                            board[i][j] = getRandomCrypto();
                            hasMatches = true;
                        }
                    }
                }
            }
        }

        function checkMatchAt(row, col) {
            const crypto = board[row][col];
            if (col >= 2 && board[row][col-1].name === crypto.name && board[row][col-2].name === crypto.name) {
                return true;
            }
            if (row >= 2 && board[row-1][col].name === crypto.name && board[row-2][col].name === crypto.name) {
                return true;
            }
            return false;
        }

        function renderBoard() {
            const boardElement = document.getElementById('gameBoard');
            boardElement.innerHTML = '';
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    const icon = document.createElement('div');
                    icon.className = 'crypto-icon';
                    
                    const img = document.createElement('img');
                    img.src = board[i][j].icon;
                    img.alt = board[i][j].name;
                    img.loading = 'lazy';
                    
                    icon.appendChild(img);
                    cell.appendChild(icon);
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    
                    // Add touch events for drag and swipe
                    cell.addEventListener('touchstart', (e) => handleTouchStart(e, i, j), { passive: false });
                    cell.addEventListener('touchmove', (e) => handleTouchMove(e, i, j), { passive: false });
                    cell.addEventListener('touchend', (e) => handleTouchEnd(e, i, j), { passive: false });
                    
                    // Add mouse events for desktop drag
                    cell.addEventListener('mousedown', (e) => handleMouseDown(e, i, j));
                    cell.addEventListener('mouseenter', (e) => handleMouseEnter(e, i, j));
                    cell.addEventListener('mouseup', (e) => handleMouseUp(e, i, j));
                    
                    boardElement.appendChild(cell);
                }
            }
            updateStats();
        }

        // Touch event handlers
        function handleTouchStart(e, row, col) {
            e.preventDefault();
            
            if (moves <= 0) return;
            
            const touch = e.touches[0];
            touchStartPos = {
                x: touch.clientX,
                y: touch.clientY,
                row: row,
                col: col,
                time: Date.now()
            };
            
            isSwipeMode = true;
            dragStartCell = { row, col };
            
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
                cell.classList.add('dragging');
            }
        }

        function handleTouchMove(e, row, col) {
            e.preventDefault();
            
            if (!isSwipeMode || !touchStartPos) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - touchStartPos.x;
            const deltaY = touch.clientY - touchStartPos.y;
            
            // Check if we've moved far enough to consider it a swipe
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > swipeThreshold) {
                // Determine direction
                let direction = null;
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    direction = deltaX > 0 ? 'right' : 'left';
                } else {
                    direction = deltaY > 0 ? 'down' : 'up';
                }
                
                // Calculate target cell based on direction
                let targetRow = touchStartPos.row;
                let targetCol = touchStartPos.col;
                
                switch (direction) {
                    case 'up': targetRow--; break;
                    case 'down': targetRow++; break;
                    case 'left': targetCol--; break;
                    case 'right': targetCol++; break;
                }
                
                // Check if target is valid
                if (targetRow >= 0 && targetRow < BOARD_SIZE && targetCol >= 0 && targetCol < BOARD_SIZE) {
                    dragEndCell = { row: targetRow, col: targetCol };
                    
                    // Visual feedback
                    const targetCellElement = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
                    if (targetCellElement) {
                        // Remove previous drag-over classes
                        document.querySelectorAll('.drag-over').forEach(cell => cell.classList.remove('drag-over'));
                        targetCellElement.classList.add('drag-over');
                    }
                }
            }
        }

        function handleTouchEnd(e, row, col) {
            e.preventDefault();
            
            if (!isSwipeMode || !touchStartPos) return;
            
            // Check if this was actually a tap (short duration, small distance)
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - touchStartPos.time;
            
            // If it was a quick tap (less than 200ms) and small distance, treat as click
            if (touchDuration < 200 && !dragEndCell) {
                // Reset swipe mode and trigger click
                isSwipeMode = false;
                touchStartPos = null;
                
                // Trigger the click handler
                handleCellClick(row, col);
                return;
            }
            
            // Clean up visual feedback
            document.querySelectorAll('.dragging').forEach(cell => cell.classList.remove('dragging'));
            document.querySelectorAll('.drag-over').forEach(cell => cell.classList.remove('drag-over'));
            
            // If we have a valid drag, perform the swap
            if (dragEndCell && dragStartCell) {
                if (isAdjacent(dragStartCell, dragEndCell)) {
                    swapCells(dragStartCell, dragEndCell);
                }
            }
            
            // Reset variables
            isSwipeMode = false;
            dragStartCell = null;
            dragEndCell = null;
            touchStartPos = null;
        }

        // Mouse event handlers for desktop
        function handleMouseDown(e, row, col) {
            if (moves <= 0) return;
            
            e.preventDefault();
            isDragging = true;
            dragStartCell = { row, col };
            
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
                cell.classList.add('dragging');
            }
        }

        function handleMouseEnter(e, row, col) {
            if (!isDragging || !dragStartCell) return;
            
            if (isAdjacent(dragStartCell, { row, col })) {
                dragEndCell = { row, col };
                
                const targetCell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (targetCell) {
                    document.querySelectorAll('.drag-over').forEach(cell => cell.classList.remove('drag-over'));
                    targetCell.classList.add('drag-over');
                }
            }
        }

        function handleMouseUp(e, row, col) {
            if (!isDragging) return;
            
            // Clean up visual feedback
            document.querySelectorAll('.dragging').forEach(cell => cell.classList.remove('dragging'));
            document.querySelectorAll('.drag-over').forEach(cell => cell.classList.remove('drag-over'));
            
            // Perform swap if valid
            if (dragEndCell && dragStartCell) {
                if (isAdjacent(dragStartCell, dragEndCell)) {
                    swapCells(dragStartCell, dragEndCell);
                }
            }
            
            // Reset
            isDragging = false;
            dragStartCell = null;
            dragEndCell = null;
        }

        // Global mouse up to handle dragging outside cells
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                document.querySelectorAll('.dragging').forEach(cell => cell.classList.remove('dragging'));
                document.querySelectorAll('.drag-over').forEach(cell => cell.classList.remove('drag-over'));
                isDragging = false;
                dragStartCell = null;
                dragEndCell = null;
            }
        });

        function handleCellClick(row, col) {
            if (moves <= 0) return;
            
            // –ï—Å–ª–∏ –º—ã –≤ —Ä–µ–∂–∏–º–µ —Å–≤–∞–π–ø–∞, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫–∏
            if (isSwipeMode || isDragging) return;

            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (!selectedCell) {
                selectedCell = { row, col };
                cell.classList.add('selected');
            } else {
                const prevCell = document.querySelector(`[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
                prevCell.classList.remove('selected');
                
                if (isAdjacent(selectedCell, { row, col })) {
                    swapCells(selectedCell, { row, col });
                    selectedCell = null;
                } else {
                    selectedCell = { row, col };
                    cell.classList.add('selected');
                }
            }
        }

        function isAdjacent(cell1, cell2) {
            const rowDiff = Math.abs(cell1.row - cell2.row);
            const colDiff = Math.abs(cell1.col - cell2.col);
            return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
        }

        function swapCells(cell1, cell2) {
            const temp = board[cell1.row][cell1.col];
            board[cell1.row][cell1.col] = board[cell2.row][cell2.col];
            board[cell2.row][cell2.col] = temp;
            
            const matches = findMatches();
            
            if (matches.length > 0) {
                moves--;
                processMatches(matches);
            } else {
                board[cell2.row][cell2.col] = board[cell1.row][cell1.col];
                board[cell1.row][cell1.col] = temp;
                renderBoard();
            }
        }

        function findMatches() {
            const matches = [];
            const processed = new Set();
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE - 2; j++) {
                    const current = board[i][j];
                    let matchLength = 1;
                    
                    while (j + matchLength < BOARD_SIZE && board[i][j + matchLength].name === current.name) {
                        matchLength++;
                    }
                    
                    if (matchLength >= 3) {
                        for (let k = 0; k < matchLength; k++) {
                            const key = `${i}-${j + k}`;
                            if (!processed.has(key)) {
                                matches.push({ row: i, col: j + k, crypto: current, length: matchLength });
                                processed.add(key);
                            }
                        }
                    }
                }
            }
            
            for (let j = 0; j < BOARD_SIZE; j++) {
                for (let i = 0; i < BOARD_SIZE - 2; i++) {
                    const current = board[i][j];
                    let matchLength = 1;
                    
                    while (i + matchLength < BOARD_SIZE && board[i + matchLength][j].name === current.name) {
                        matchLength++;
                    }
                    
                    if (matchLength >= 3) {
                        for (let k = 0; k < matchLength; k++) {
                            const key = `${i + k}-${j}`;
                            if (!processed.has(key)) {
                                matches.push({ row: i + k, col: j, crypto: current, length: matchLength });
                                processed.add(key);
                            }
                        }
                    }
                }
            }
            
            return matches;
        }

        function processMatches(matches) {
            if (matches.length === 0) return;
            
            const basePoints = matches.length * 10;
            combo++;
            const comboBonus = combo > 1 ? combo * 20 : 0;
            const matchBonus = matches.some(m => m.length >= 5) ? 100 : 0;
            
            const earnedPoints = basePoints + comboBonus + matchBonus;
            score += earnedPoints;
            
            updateQuest('score', score);
            if (combo >= 3) updateQuest('combo', combo);
            
            matches.forEach(match => {
                if (match.crypto.name === 'BTC') {
                    updateQuest('btc', 1, true);
                }
                if (match.length >= 5) {
                    updateQuest('bigmatch', 1, true);
                }
            });
            
            matches.forEach(match => {
                const cell = document.querySelector(`[data-row="${match.row}"][data-col="${match.col}"]`);
                if (cell) cell.classList.add('matched');
            });
            
            if (combo > 1) {
                showComboText(`COMBO x${combo}!`);
            }
            
            setTimeout(() => {
                matches.forEach(match => {
                    board[match.row][match.col] = null;
                });
                
                dropCells();
                fillEmpty();
                renderBoard();
                saveGameData(true); // –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Ö–æ–¥–∞
                
                setTimeout(() => {
                    const newMatches = findMatches();
                    if (newMatches.length > 0) {
                        processMatches(newMatches);
                    } else {
                        combo = 0;
                        checkLevelComplete();
                        checkGameOver();
                    }
                }, 300);
            }, 300);
        }

        function dropCells() {
            for (let j = 0; j < BOARD_SIZE; j++) {
                let emptyRow = BOARD_SIZE - 1;
                for (let i = BOARD_SIZE - 1; i >= 0; i--) {
                    if (board[i][j] !== null) {
                        if (i !== emptyRow) {
                            board[emptyRow][j] = board[i][j];
                            board[i][j] = null;
                        }
                        emptyRow--;
                    }
                }
            }
        }

        function fillEmpty() {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === null) {
                        board[i][j] = getRandomCrypto();
                    }
                }
            }
        }

        function checkLevelComplete() {
            if (score >= targetScore) {
                const levelMovesLeft = 30 - moves + (level - 1) * 20;
                level++;
                targetScore = level * 1000;
                moves += 20;
                boosters++;
                updateQuest('level', level);
                
                if (levelMovesLeft >= 20) {
                    updateQuest('efficiency', 1, true);
                }
                
                alert(`üéâ –£—Ä–æ–≤–µ–Ω—å ${level} –ø—Ä–æ–π–¥–µ–Ω!\n+20 —Ö–æ–¥–æ–≤\n+1 –±—É—Å—Ç–µ—Ä`);
            }
        }

        function checkGameOver() {
            if (moves <= 0 && score < targetScore) {
                stopAutoSave();
                updateQuest('games', 1, true);
                saveToLeaderboard(score);
                saveGameData(false); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–µ–∑ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä—ã
                
                setTimeout(() => {
                    if (confirm(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!\n\n–û—á–∫–∏: ${score}\n–£—Ä–æ–≤–µ–Ω—å: ${level}\n\n–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É?`)) {
                        restartGame();
                    }
                }, 500);
            }
        }

        function useBooster() {
            if (boosters <= 0) {
                alert('‚ùå –ë—É—Å—Ç–µ—Ä—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å! –í—ã–ø–æ–ª–Ω—è–π—Ç–µ –∑–∞–¥–∞–Ω–∏—è —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–æ–ª—å—à–µ.');
                return;
            }
            
            boosters--;
            moves += 5;
            saveGameData(true); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±—É—Å—Ç–µ—Ä–∞
            
            let removed = 0;
            while (removed < 5) {
                const row = Math.floor(Math.random() * BOARD_SIZE);
                const col = Math.floor(Math.random() * BOARD_SIZE);
                if (board[row][col] !== null) {
                    board[row][col] = null;
                    removed++;
                }
            }
            
            dropCells();
            fillEmpty();
            renderBoard();
            
            setTimeout(() => {
                const matches = findMatches();
                if (matches.length > 0) {
                    processMatches(matches);
                }
            }, 300);
        }

        function updateStats() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('moves').textContent = moves;
            document.getElementById('boosters').textContent = boosters;
            document.getElementById('boosterBtn').textContent = `‚ö° –ë—É—Å—Ç–µ—Ä (${boosters})`;
            document.getElementById('boosterBtn').disabled = boosters <= 0;
            
            const progress = Math.min((score / targetScore) * 100, 100);
            document.getElementById('progress').style.width = progress + '%';
        }

        function restartGame() {
            stopAutoSave();
            updateQuest('games', 1, true);
            saveGameData(false); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–µ—Ä–µ–¥ —Ä–µ—Å—Ç–∞—Ä—Ç–æ–º
            
            score = 0;
            level = 1;
            moves = 30;
            combo = 0;
            targetScore = 1000;
            selectedCell = null;
            initBoard();
            startAutoSave();
        }

        function updateQuest(type, value, increment = false) {
            quests.forEach(quest => {
                if (quest.type === type && !quest.claimed) {
                    if (increment) {
                        quest.current += value;
                    } else {
                        quest.current = Math.max(quest.current, value);
                    }
                }
            });
            saveGameData();
        }

        function showQuests() {
            console.log('üéÆ Telegram WebApp Data:', tg?.initDataUnsafe);
            console.log('üë§ User ID:', tg?.initDataUnsafe?.user?.id);
            console.log('üìã Total quests:', quests.length);
            
            const modal = document.getElementById('questModal');
            const questList = document.getElementById('questList');
            questList.innerHTML = '';
            
            // Force add subscription quest if not present
            const subscribeQuest = quests.find(q => q.type === 'subscribe');
            if (!subscribeQuest) {
                quests.push({
                    id: 9, 
                    title: '–ü–æ–¥–ø–∏—Å—á–∏–∫', 
                    description: '–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª', 
                    target: 1, 
                    current: 0, 
                    type: 'subscribe', 
                    reward: 5, 
                    claimed: false, 
                    channelUsername: '@cryptonftded'
                });
                console.log('‚ûï Added subscription quest');
            }
            
            quests.forEach(quest => {
                console.log(`üìã Quest: ${quest.title}, Type: ${quest.type}`);
                
                const progress = Math.min((quest.current / quest.target) * 100, 100);
                const isCompleted = quest.current >= quest.target;
                const canClaim = isCompleted && !quest.claimed;
                
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item' + (quest.claimed ? ' quest-completed' : '') + (quest.type === 'subscribe' ? ' subscribe-quest' : '');
                
                if (quest.type === 'subscribe') {
                    questDiv.innerHTML = `
                        <div class="quest-header">
                            <div class="quest-title">${quest.title}</div>
                            <div class="quest-reward">+${quest.reward} –±—É—Å—Ç–µ—Ä${quest.reward > 1 ? '–∞' : ''}</div>
                        </div>
                        <div class="quest-progress">${quest.description}</div>
                        <div class="quest-bar">
                            <div class="quest-bar-fill" style="width: ${progress}%"></div>
                        </div>
                        ${!quest.claimed ? `
                            <button class="subscribe-btn" onclick="openChannel()">
                                üì¢ –û—Ç–∫—Ä—ã—Ç—å –∫–∞–Ω–∞–ª
                            </button>
                            <button class="verify-btn" onclick="verifySubscription()">
                                ‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É
                            </button>
                            <div id="subscription-status" class="verification-status"></div>
                        ` : ''}
                        ${quest.claimed ? '<div style="text-align: center; color: #4CAF50; margin-top: 8px; font-weight: bold;">‚úì –í—ã–ø–æ–ª–Ω–µ–Ω–æ</div>' : ''}
                    `;
                } else {
                    questDiv.innerHTML = `
                        <div class="quest-header">
                            <div class="quest-title">${quest.title}</div>
                            <div class="quest-reward">+${quest.reward} –±—É—Å—Ç–µ—Ä${quest.reward > 1 ? '–∞' : ''}</div>
                        </div>
                        <div class="quest-progress">${quest.description}: ${quest.current}/${quest.target}</div>
                        <div class="quest-bar">
                            <div class="quest-bar-fill" style="width: ${progress}%"></div>
                        </div>
                        ${canClaim ? `<button class="claim-btn" onclick="claimQuest(${quest.id})">‚úÖ –ü–æ–ª—É—á–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É</button>` : ''}
                        ${quest.claimed ? '<div style="text-align: center; color: #4CAF50; margin-top: 8px; font-weight: bold;">‚úì –í—ã–ø–æ–ª–Ω–µ–Ω–æ</div>' : ''}
                    `;
                }
                
                questList.appendChild(questDiv);
            });
            
            modal.classList.add('active');
        }

        function claimQuest(questId) {
            const quest = quests.find(q => q.id === questId);
            if (quest && quest.current >= quest.target && !quest.claimed) {
                quest.claimed = true;
                boosters += quest.reward;
                updateStats();
                saveGameData(true); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–∞–≥—Ä–∞–¥—ã
                showQuests();
                alert(`üéÅ –ü–æ–ª—É—á–µ–Ω–æ ${quest.reward} –±—É—Å—Ç–µ—Ä${quest.reward > 1 ? '–∞' : ''}!`);
            }
        }

        function showComboText(text) {
            const comboDiv = document.createElement('div');
            comboDiv.className = 'combo-text';
            comboDiv.textContent = text;
            document.body.appendChild(comboDiv);
            
            setTimeout(() => {
                comboDiv.remove();
            }, 1000);
        }

        async function saveToLeaderboard(finalScore) {
            const userName = tg?.initDataUnsafe?.user?.first_name || '–ò–≥—Ä–æ–∫';
            const userId = tg?.initDataUnsafe?.user?.id || 'local';
            
            const entry = {
                id: userId,
                name: userName,
                score: finalScore,
                level: level,
                date: new Date().toISOString(),
                user_id: userId
            };

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥
            const localLeaderboard = JSON.parse(localStorage.getItem('cryptoCrushLeaderboard') || '[]');
            localLeaderboard.push(entry);
            localLeaderboard.sort((a, b) => b.score - a.score);
            localLeaderboard.splice(10);
            localStorage.setItem('cryptoCrushLeaderboard', JSON.stringify(localLeaderboard));

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Telegram Cloud
            if (tg && tg.CloudStorage) {
                try {
                    tg.CloudStorage.setItem('leaderboard', JSON.stringify(localLeaderboard), (error) => {
                        if (error) console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞:', error);
                    });
                } catch (e) {
                    console.error('–û—à–∏–±–∫–∞:', e);
                }
            }
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥
            await submitToGlobalLeaderboard(entry);
        }
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥
        async function submitToGlobalLeaderboard(entry) {
            try {
                // –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
                const globalData = JSON.parse(localStorage.getItem('globalLeaderboard') || '[]');
                
                // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                const filteredData = globalData.filter(item => item.id !== entry.id);
                filteredData.push(entry);
                
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ø 100
                filteredData.sort((a, b) => b.score - a.score);
                const top100 = filteredData.slice(0, 100);
                
                localStorage.setItem('globalLeaderboard', JSON.stringify(top100));
                
                // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ backend –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
                try {
                    const response = await fetch(GLOBAL_LEADERBOARD_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(entry)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('üèÜ –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥:', result);
                        
                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ä–∞–Ω–≥–µ
                        if (result.rank) {
                            showRankNotification(result.rank, result.totalPlayers);
                        }
                    } else {
                        console.log('üì° Backend –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ');
                    }
                } catch (apiError) {
                    console.log('üì° Backend –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ');
                }
                
                console.log('üèÜ –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω:', entry.score);
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥:', error);
            }
        }
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ä–∞–Ω–≥–µ
        function showRankNotification(rank, totalPlayers) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 15px 25px;
                border-radius: 25px;
                font-weight: bold;
                z-index: 1002;
                animation: slideDown 0.3s ease-out;
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
                text-align: center;
            `;
            notification.innerHTML = `
                üèÜ –ù–æ–≤—ã–π –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–∞–Ω–≥: #${rank}<br>
                <small>–∏–∑ ${totalPlayers} –∏–≥—Ä–æ–∫–æ–≤</small>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 4000);
        }
        
        // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞
        async function syncGlobalLeaderboard() {
            if (isLeaderboardSyncing) return;
            
            isLeaderboardSyncing = true;
            
            try {
                // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å backend
                try {
                    const response = await fetch(GLOBAL_LEADERBOARD_API);
                    if (response.ok) {
                        const data = await response.json();
                        globalLeaderboard = data;
                        lastSyncTime = new Date();
                        
                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ –∫–∞–∫ –∫—ç—à
                        localStorage.setItem('globalLeaderboard', JSON.stringify(data));
                        console.log('üîÑ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω —Å backend:', data.length, '–∏–≥—Ä–æ–∫–æ–≤');
                        return;
                    }
                } catch (apiError) {
                    console.log('üì° Backend –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ');
                }
                
                // Fallback –Ω–∞ localStorage
                const data = JSON.parse(localStorage.getItem('globalLeaderboard') || '[]');
                globalLeaderboard = data;
                lastSyncTime = new Date();
                
                console.log('üîÑ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥ –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ localStorage:', data.length, '–∏–≥—Ä–æ–∫–æ–≤');
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞:', error);
            } finally {
                isLeaderboardSyncing = false;
            }
        }

        function getHighScore() {
            const leaderboard = JSON.parse(localStorage.getItem('cryptoCrushLeaderboard') || '[]');
            return leaderboard.length > 0 ? leaderboard[0].score : 0;
        }

        async function showLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            const leaderboardList = document.getElementById('leaderboardList');
            
            leaderboardList.innerHTML = '<div style="text-align: center; padding: 20px;">–ó–∞–≥—Ä—É–∑–∫–∞...</div>';
            modal.classList.add('active');

            // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º
            await syncGlobalLeaderboard();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
            const syncStatus = document.createElement('div');
            syncStatus.className = 'leaderboard-sync-status';
            if (lastSyncTime) {
                const timeAgo = getTimeAgo(lastSyncTime);
                syncStatus.innerHTML = `üåê –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥<br><small>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: ${timeAgo}</small>`;
            } else {
                syncStatus.innerHTML = 'üåê –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥<br><small>–ó–∞–≥—Ä—É–∑–∫–∞...</small>';
            }
            
            leaderboardList.innerHTML = '';
            leaderboardList.appendChild(syncStatus);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–¥–µ—Ä–±–æ—Ä–¥
            if (globalLeaderboard.length === 0) {
                leaderboardList.innerHTML += '<div style="text-align: center; color: #666; padding: 20px;">–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</div>';
            } else {
                globalLeaderboard.slice(0, 20).forEach((entry, index) => {
                    const item = document.createElement('div');
                    const isCurrentUser = entry.id === currentUserId;
                    item.className = 'leaderboard-item' + (isCurrentUser ? ' current-player' : '');
                    
                    let badge = '';
                    if (index === 0) badge = '<span class="badge">ü•á</span>';
                    else if (index === 1) badge = '<span class="badge">ü•à</span>';
                    else if (index === 2) badge = '<span class="badge">ü•â</span>';
                    
                    const dateStr = new Date(entry.date).toLocaleDateString('ru-RU');
                    
                    item.innerHTML = `
                        <div class="leaderboard-rank">#${index + 1}</div>
                        <div class="leaderboard-name">${entry.name} ${badge} ${isCurrentUser ? '(–í—ã)' : ''}</div>
                        <div class="leaderboard-score">${entry.score}</div>
                    `;
                    
                    if (entry.level) {
                        item.innerHTML += `<div class="leaderboard-level">Lvl ${entry.level}</div>`;
                    }
                    
                    leaderboardList.appendChild(item);
                });
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
            const syncButton = document.createElement('button');
            syncButton.className = 'sync-button';
            syncButton.textContent = 'üîÑ –û–±–Ω–æ–≤–∏—Ç—å';
            syncButton.onclick = () => {
                syncButton.disabled = true;
                syncButton.textContent = 'üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...';
                syncGlobalLeaderboard().then(() => {
                    setTimeout(() => {
                        showLeaderboard();
                    }, 1000);
                });
            };
            
            leaderboardList.appendChild(syncButton);
        }
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return '—Ç–æ–ª—å–∫–æ —á—Ç–æ';
            if (seconds < 3600) return `${Math.floor(seconds / 60)} –º–∏–Ω. –Ω–∞–∑–∞–¥`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)} —á. –Ω–∞–∑–∞–¥`;
            return `${Math.floor(seconds / 86400)} –¥. –Ω–∞–∑–∞–¥`;
        }

        function displayLeaderboard(leaderboard, leaderboardList) {
            leaderboardList.innerHTML = '';
            
            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</div>';
            } else {
                leaderboard.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = 'leaderboard-item';
                    
                    let badge = '';
                    if (index === 0) badge = '<span class="badge">ü•á</span>';
                    else if (index === 1) badge = '<span class="badge">ü•à</span>';
                    else if (index === 2) badge = '<span class="badge">ü•â</span>';
                    
                    item.innerHTML = `
                        <div class="leaderboard-rank">#${index + 1}</div>
                        <div class="leaderboard-name">${entry.name} ${badge}</div>
                        <div class="leaderboard-score">${entry.score}</div>
                    `;
                    leaderboardList.appendChild(item);
                });
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫–∞–Ω–∞–ª–∞
        const CHANNEL_USERNAME = '@cryptonftded'; // –í–∞—à –∫–∞–Ω–∞–ª
        
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞
        // Backend API hosted separately on Render.com
        const GLOBAL_LEADERBOARD_API = 'https://crypto-crush-game.onrender.com/api/leaderboard';
        const LEADERBOARD_SYNC_INTERVAL = 60000; // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
        let globalLeaderboard = [];
        let lastSyncTime = null;
        let isLeaderboardSyncing = false;
        let currentUserId = null;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∫–∞–Ω–∞–ª
        async function checkChannelSubscription(userId) {
            if (!tg?.initDataUnsafe?.user?.id) {
                return false;
            }

            try {
                // –ó–∞–ø—Ä–æ—Å –Ω–∞ backend –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏
                const response = await fetch(`${GLOBAL_LEADERBOARD_API}/check-subscription`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId, channel: CHANNEL_USERNAME })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    return result.isSubscribed;
                }
                
                return false;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏:', error);
                return false;
            }
        }

        // –û—Ç–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞
        function openChannel() {
            const channelUrl = `https://t.me/${CHANNEL_USERNAME.replace('@', '')}`;
            if (tg) {
                tg.openTelegramLink(channelUrl);
            } else {
                window.open(channelUrl, '_blank');
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è –∑–∞–¥–∞–Ω–∏—è
        async function verifySubscription() {
            const userId = tg?.initDataUnsafe?.user?.id;
            if (!userId) {
                alert('‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
                return;
            }

            const quest = quests.find(q => q.type === 'subscribe');
            const statusDiv = document.getElementById('subscription-status');
            
            if (statusDiv) {
                statusDiv.innerHTML = 'üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏...';
                statusDiv.style.color = '#667eea';
            }

            try {
                const isSubscribed = await checkChannelSubscription(userId);
                
                if (isSubscribed) {
                    updateQuest('subscribe', 1, true);
                    if (statusDiv) {
                        statusDiv.innerHTML = '‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!';
                        statusDiv.style.color = '#4CAF50';
                    }
                    setTimeout(() => {
                        showQuests();
                    }, 1500);
                } else {
                    if (statusDiv) {
                        statusDiv.innerHTML = '‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –∫–∞–Ω–∞–ª';
                        statusDiv.style.color = '#f44336';
                    }
                }
            } catch (error) {
                if (statusDiv) {
                    statusDiv.innerHTML = '‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ';
                    statusDiv.style.color = '#ff9800';
                }
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        async function init() {
            // –ü–æ–ª—É—á–∞–µ–º ID —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            currentUserId = tg?.initDataUnsafe?.user?.id || 'local_' + Date.now();

            await loadGameData();

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–æ–≤—É—é –¥–æ—Å–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
            if (!boardRestoredFromSave) {
                initBoard();
            }

            startAutoSave();

            // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞
            syncGlobalLeaderboard();
            setInterval(syncGlobalLeaderboard, LEADERBOARD_SYNC_INTERVAL);
        }

        init();

        window.addEventListener('beforeunload', () => {
            if (moves > 0) {
                saveGameData(true);
            }
        });

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–∏ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–∏ Telegram Mini App
        if (tg) {
            tg.onEvent('viewportChanged', () => {
                if (moves > 0) {
                    saveGameData(true);
                }
            });
        }

        document.addEventListener('gesturestart', function (e) {
            e.preventDefault();
        });
    </script>
</body>
</html>